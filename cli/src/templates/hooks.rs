//! Hook template generators for git and Claude Code

use super::ProjectType;

/// Generate pre-commit hook for RoyalBit Asimov
pub fn precommit_hook_template(project_type: ProjectType) -> String {
    let checks = match project_type {
        ProjectType::Rust => {
            r#"echo "Checking formatting..."
cargo fmt --check

echo "Running clippy..."
cargo clippy --all-targets -- -D warnings

echo "Running tests..."
cargo test"#
        }
        ProjectType::Python => {
            r#"echo "Checking formatting..."
ruff format --check . 2>/dev/null || true

echo "Running linter..."
ruff check . 2>/dev/null || true

echo "Running tests..."
pytest 2>/dev/null || true"#
        }
        ProjectType::Node => {
            r#"echo "Checking formatting..."
npm run format:check 2>/dev/null || true

echo "Running linter..."
npm run lint 2>/dev/null || true

echo "Running tests..."
npm test 2>/dev/null || true"#
        }
        ProjectType::Go => {
            r#"echo "Checking formatting..."
gofmt -l . | read && echo "Files need formatting" && exit 1 || true

echo "Running linter..."
golangci-lint run 2>/dev/null || true

echo "Running tests..."
go test ./... 2>/dev/null || true"#
        }
        ProjectType::Flutter => {
            r#"echo "Checking formatting..."
dart format --set-exit-if-changed lib/ test/ 2>/dev/null || true

echo "Running analyzer..."
dart analyze lib/ 2>/dev/null || flutter analyze 2>/dev/null || true

echo "Running tests..."
flutter test 2>/dev/null || true"#
        }
        ProjectType::Docs | ProjectType::Generic => {
            r#"echo "Checking documentation..."
# Add your checks here"#
        }
    };

    format!(
        r#"#!/bin/bash
# Pre-commit hook for RoyalBit Asimov
# Generated by asimov init --asimov

set -e

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROTOCOL REFRESH - Injects rules into fresh context (survives compaction)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if command -v asimov &> /dev/null; then
    asimov refresh
fi

{}

# RoyalBit Asimov validation
if command -v asimov &> /dev/null; then
    echo "Validating protocol files..."
    asimov validate . || true

    echo "Linting documentation..."
    asimov lint-docs . || exit 1
else
    echo ""
    echo "âš ï¸  asimov CLI not installed - skipping protocol validation"
    echo "   Install with: cargo install royalbit-asimov"
    echo "   Then re-run your commit to validate protocol files."
    echo ""
fi

echo "Pre-commit checks passed!"
"#,
        checks
    )
}

/// Generate hook installer script
pub fn hook_installer_template() -> String {
    r#"#!/bin/bash
# Install git hooks for RoyalBit Asimov
# Generated by asimov init --asimov

set -e

HOOK_DIR=".git/hooks"
SRC_DIR=".hooks"

if [ ! -d ".git" ]; then
    echo "Error: Not a git repository"
    exit 1
fi

mkdir -p "$HOOK_DIR"

if [ -f "$SRC_DIR/pre-commit" ]; then
    cp "$SRC_DIR/pre-commit" "$HOOK_DIR/pre-commit"
    chmod +x "$HOOK_DIR/pre-commit"
    echo "âœ“ Installed pre-commit hook"
else
    echo "Error: $SRC_DIR/pre-commit not found"
    exit 1
fi

echo "Hooks installed successfully!"
"#
    .to_string()
}

/// Returns true if project type uses cargo-husky (Rust projects)
pub fn uses_cargo_husky(project_type: ProjectType) -> bool {
    matches!(project_type, ProjectType::Rust)
}

/// Generate .claude/settings.json for Claude Code hooks
pub fn claude_settings_json() -> String {
    r#"{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/session-start.sh",
            "timeout": 30
          }
        ]
      }
    ],
    "PreCompact": [
      {
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/pre-compact.sh",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
"#
    .to_string()
}

/// Generate .claude/hooks/session-start.sh for Claude Code
pub fn claude_session_start_hook() -> String {
    r#"#!/bin/bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ROYALBIT ASIMOV - SessionStart Hook (v8.1.0)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Triggers: startup, resume, clear
# Purpose: Auto-initialize RoyalBit Asimov on every session start
#
# When exit code is 0, stdout is injected into Claude's context.
#
# v8.1.0: project.yaml added for project context (ADR-032)
# v8.0.0: Protocols are hardcoded in binary - run `asimov warmup` to load
#
# Protocol: https://github.com/royalbit/asimov
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -e

cat << 'EOF'
ğŸ”¥ ROYALBIT ASIMOV ACTIVE (v8.1.0)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SESSION START - Autonomous Development Protocol Initialized
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMMEDIATE ACTIONS REQUIRED:
1. Run: asimov warmup (loads hardcoded protocols + validates)
2. Read .asimov/roadmap.yaml for current version and next milestone
3. Present next milestone to user
4. Wait for "go" to start autonomous execution

CORE RULES (non-negotiable):
- 4 hour MAX session duration
- 1 milestone per session
- Tests MUST pass before release
- ZERO warnings policy

Say "go" to start autonomous execution.
Say "skip" to pick a different milestone.
Say "plan" to discuss approach first.

ASIMOV MODE:
When user says "asimov mode", display:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¤– ASIMOV MODE - AUTONOMOUS EXECUTION ENGAGED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Then proceed with full autonomous execution for 4h MAX or until roadmap exhausted.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF

exit 0
"#
    .to_string()
}

/// Generate .claude/hooks/pre-compact.sh for Claude Code
pub fn claude_pre_compact_hook() -> String {
    r#"#!/bin/bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ROYALBIT ASIMOV - PreCompact Hook (v8.1.0)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Triggers: Before context compaction (auto or manual)
# Purpose: Re-inject protocol context that will survive compaction summary
#
# CRITICAL: Compaction happens every ~15 minutes with MAX_THINKING_TOKENS=200000
# This hook fires BEFORE compaction, injecting context into the summary.
#
# When exit code is 0, stdout is injected into Claude's context.
#
# v8.0.0: Protocols are hardcoded in binary - run `asimov warmup` to reload
#
# Protocol: https://github.com/royalbit/asimov
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -e

cat << 'EOF'
ğŸ”„ ROYALBIT ASIMOV REFRESH (Pre-Compaction)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CONTEXT REFRESH - Injecting protocol rules before compaction
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANT: Compaction is about to occur. These rules MUST survive:

CORE RULES (non-negotiable):
- 4 hour MAX session duration
- 1 milestone per session
- Tests MUST pass before release
- ZERO warnings policy
- NO scope creep ("Let me also..." = NO)

POST-COMPACTION ACTIONS:
1. Run: asimov warmup (protocols are hardcoded in v8.0.0)
2. Re-read .asimov/roadmap.yaml for current milestone
3. Check TodoWrite for in-progress tasks
4. Continue where you left off

CONFUSION PROTOCOL:
If uncertain: STOP â†’ run `asimov warmup` â†’ re-read roadmap.yaml â†’ continue

ETHICS (Priority 0):
- Do no harm (financial, physical, privacy, deception)
- Transparency over velocity
- When in doubt, ask human

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF

exit 0
"#
    .to_string()
}

/// Generate .git/hooks/pre-commit for Git
pub fn git_precommit_hook() -> String {
    r#"#!/bin/bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ROYALBIT ASIMOV - Git Pre-commit Hook (v8.16.1)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Auto-installed by `asimov init` or `asimov warmup`
# Hardcoded in binary - restored on tampering
#
# Protocol: https://github.com/royalbit/asimov
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -e

echo "Running pre-commit checks..."

# v8.16.1: Rust formatting check (if Cargo.toml exists)
if [ -f "Cargo.toml" ] || [ -f "cli/Cargo.toml" ]; then
    echo "Checking Rust formatting..."
    if [ -f "cli/Cargo.toml" ]; then
        cd cli && cargo fmt --all -- --check || {
            echo ""
            echo "âŒ Rust formatting check failed!"
            echo "   Run: cd cli && cargo fmt --all"
            echo ""
            exit 1
        }
        cd ..
    else
        cargo fmt --all -- --check || {
            echo ""
            echo "âŒ Rust formatting check failed!"
            echo "   Run: cargo fmt --all"
            echo ""
            exit 1
        }
    fi
fi

# Protocol refresh - injects rules into fresh context (survives compaction)
if command -v asimov &> /dev/null; then
    asimov refresh
fi

# Validate protocol files
if command -v asimov &> /dev/null; then
    echo "Validating protocol files..."
    asimov validate || exit 1

    echo "Linting documentation..."
    asimov lint-docs . || exit 1
else
    echo ""
    echo "âš ï¸  asimov CLI not installed - skipping protocol validation"
    echo "   Install with: cargo install royalbit-asimov"
    echo ""
fi

echo "Pre-commit checks passed!"
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_uses_cargo_husky() {
        assert!(uses_cargo_husky(ProjectType::Rust));
        assert!(!uses_cargo_husky(ProjectType::Python));
        assert!(!uses_cargo_husky(ProjectType::Node));
        assert!(!uses_cargo_husky(ProjectType::Go));
        assert!(!uses_cargo_husky(ProjectType::Flutter));
        assert!(!uses_cargo_husky(ProjectType::Docs));
        assert!(!uses_cargo_husky(ProjectType::Generic));
    }

    #[test]
    fn test_git_precommit_hook() {
        let hook = git_precommit_hook();
        assert!(hook.contains("#!/bin/sh") || hook.contains("#!/bin/bash"));
    }

    #[test]
    fn test_precommit_hook_template() {
        let hook = precommit_hook_template(ProjectType::Rust);
        assert!(hook.contains("cargo") || hook.contains("Checking"));
    }

    #[test]
    fn test_hook_installer_template() {
        let installer = hook_installer_template();
        assert!(installer.contains("#!/bin/sh") || installer.contains("#!/bin/bash"));
    }

    #[test]
    fn test_claude_settings_json() {
        let settings = claude_settings_json();
        let json: Result<serde_json::Value, _> = serde_json::from_str(&settings);
        assert!(json.is_ok(), "Claude settings should be valid JSON");
    }

    #[test]
    fn test_claude_session_start_hook() {
        let hook = claude_session_start_hook();
        assert!(
            hook.contains("#!/bin/sh") || hook.contains("#!/bin/bash") || hook.contains("asimov")
        );
    }

    #[test]
    fn test_claude_pre_compact_hook() {
        let hook = claude_pre_compact_hook();
        assert!(
            hook.contains("#!/bin/sh") || hook.contains("#!/bin/bash") || hook.contains("asimov")
        );
    }

    #[test]
    fn test_precommit_hook_all_types() {
        let types = [
            ProjectType::Rust,
            ProjectType::Python,
            ProjectType::Node,
            ProjectType::Go,
            ProjectType::Flutter,
            ProjectType::Docs,
            ProjectType::Generic,
        ];
        for pt in types {
            let hook = precommit_hook_template(pt);
            assert!(!hook.is_empty(), "Hook for {:?} should not be empty", pt);
        }
    }
}
